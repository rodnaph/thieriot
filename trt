#!/usr/bin/env perl

use strict;

use Cwd;
use YAML qw(LoadFile);
use JSON qw(decode_json);
use LWP::UserAgent;
use HTTP::Request::Common;
use File::Basename qw(dirname);

use constant VERSION => '0.0.5';

#
# signal an error message and exit
#
sub error
{
    my ($message) = @_;

    print "Fatal Error: $message\n";
    exit 1;
}

#
# makes a request, adding any required auth info
#
sub make_request
{
    my ($req) = @_;
    my $ua = LWP::UserAgent->new;

    $req->authorization_basic(
        $ENV{'THIERIOT_USER'},
        $ENV{'THIERIOT_TOKEN'}
    );

    my $res = $ua->request( $req );

    if ($res->is_error) {
        error("request failed\n\n" . $res->decoded_content);
    }

    return $res;
}

#
# perform a GET and return the content
#
sub get
{
    my ($url) = @_;
    my $res = make_request(GET $url);

    return $res->decoded_content;
}

#
# fetches json from the specfied url
#
sub fetch_json
{
    my ($url) = @_;

    return decode_json(get($url));
}

#
# returns the projects name
#
sub project_name
{
    my ($config) = @_;
    my $configuredName = $config->{project_name};

    return $configuredName
        ? $configuredName
        : basename(getcwd);
}

#
# creates and returns a url to jenkins
#
sub jenkins_url
{
    my ($config, $url) = @_;

    return "http://$config->{jenkins_url}$url";
}

#
# fetch the url relative to a branch's job
#
sub job_url
{
    my ($config, $branch, $url) = @_;
    my $project = project_name($config);

    return jenkins_url($config, "/job/$project-$branch$url");
}

#
# returns url for a jobs config
#
sub config_url
{
    my ($config, $branch) = @_;

    return job_url($config, $branch, '/config.xml');
}

#
# fetches the projects jobs from jenkins
#
sub fetch_jobs
{
    my ($config) = @_;
    my $url = jenkins_url($config, '/api/json');
    my $json = fetch_json($url);
    my $project = project_name($config);
    my %jobs;

    foreach (@{$json->{jobs}}) {
        if ($_->{name} =~ m/^$project-(.*)/) {
            $jobs{$1} = $_;
        }
    }

    return %jobs;
}

#
# returns array of local branch names
#
sub fetch_branches
{
    my @branches;

    foreach (`git branch`) {
        push(@branches, substr($_, 2, -1));
    }
    
    return @branches;
}

#
# fetch a branch name by id
#
sub fetch_branch
{
    my ($id) = @_;
    my @branches = fetch_branches();
    my $name = $branches[$id - 1];

    if (!$name) {
        error('Invalid branch ID')
    }

    return $name;
}

#
# fetches the xml config for a branch
#
sub fetch_branch_config
{
    my ($config, $branch) = @_;
    my $url = config_url($config, $branch);

    return get($url);
}

#
# indicates if a job is currently building
#
sub is_building
{
    my ($job) = @_;

    return $job && substr($job->{color},-5) eq "anime";
}

#
# lists all branches, indicating if they have a job
#
sub branch_list
{
    my ($config) = @_;
    my %jobs = fetch_jobs($config);
    my @branches = fetch_branches();
    my $index = 1;

    foreach (@branches) {
        my $job = $jobs{$_};
        my $exists = $job
            ? "\e[0:36m✓\e[0m"
            : "\e[0;31m✘\e[0m";
        my $building = is_building($job)
            ? ' (building)'
            : '';

        print "$exists \e[0;32m[$index]\e[0m\t$_$building\n";
        $index++;
    }
}

#
# builds a branch specfied by index
#
sub branch_build
{
    my ($config, $branch) = @_;
    my $project = project_name($config);

    make_request(POST job_url($config, $branch, '/build'));
}

#
# creates a new branch specified by index
#
sub branch_create
{
    my ($config, $branch) = @_;
    my $project = project_name($config);
    my $xml = fetch_branch_config($config, 'master');

    $xml =~ s!<name>master</name>!<name>$branch</name>!;

    make_request(POST jenkins_url($config, '/createItem'),
                      [ mode => 'copy',
                        from => "$project-master",
                        name => "$project-$branch" ]);

    make_request(POST config_url($config, $branch),
                      Content_Type => 'text/xml',
                      Content => $xml);

    sleep(2);

    branch_build($config, $branch);
}

#
# allows deleting a branch
#
sub branch_delete
{
    my ($config, $branch) = @_;
    my $project = project_name($config);

    make_request(POST job_url($config, $branch, '/doDelete'));
}

#
# prints usage information
#
sub print_help
{
    print <<EOT;
Usage: trt ACTION ID

    create ID       Create a job for branch ID
    build ID        Build job for branch ID
    delete ID       Delete job for branch ID
    view ID         Open browser to the jobs page for the branch ID
EOT

}

#
# tries to read the config file, return hash
#
sub read_config
{
    my ($dir) = @_;
    my $config = '.thieriot.yml';
    my $path = "$dir/$config";

    if (-e $path) {
        return LoadFile($path);
    }
    else {
        if ($dir eq '/') {
            error("Config file '$config' not found...");
        }
        return read_config(dirname($dir));
    }
}

#
# main
#

my($action, $id) = @ARGV;
my $config = read_config(getcwd);
my $branch = fetch_branch($id) unless !$id;

print "Thieriot " . VERSION . " (help: 'trt help')\n\n";

if ($action eq "create") {
    branch_create($config, $branch);
    print "Created branch '$branch', and now building!\n";
}

elsif ($action eq "build") {
    branch_build($config, $branch);
    print "Branch '$branch' now building!\n";
}

elsif ($action eq "delete") {
    branch_delete($config, $branch);
    print "Branch '$branch' deleted!\n";
}

elsif ($action eq "view") {
    my $url = job_url($config, $branch, '/');
    `open $url`;
    print "Browser opened.\n";
}

else {
    if ( $action ) {
        print_help();
    }
    else {
        branch_list($config);
    }
}

print "\n";

